
<head>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
  <style>
    .grid-container {
      display: grid;
      grid-template-columns: auto auto auto;
      width: 180px;
      padding: 10px;
    }
    .grid-item {
      background-color: rgba(255, 255, 255, 0.8);
      background-color: #2196F3;
      border: 1px solid rgba(0, 0, 0, 0.8);
      padding: 20px;
      font-size: 30px;
      text-align: center;
    }
    .upSpeed {
      background-color: green;
    }
    .downSpeed {
      background-color: orange;
    }
  </style>
</head>

<script>
 let exampleSocket = new WebSocket("ws://stevengrutman.com:56112");

exampleSocket.onmessage = function(e) {
  reader = new FileReader();
  reader.onload = () => {
    var data = new Uint8Array(reader.result); // Key line!!!
    console.log(new TextDecoder().decode(data));
  };
  reader.readAsArrayBuffer(e.data);
};

function motorCommand(command){
  console.log("command:" + command)
  exampleSocket.send(command);
}
</script>

<title>Hello, my name is Shelldon</title>

<div class="grid-container">
  <button class="grid-item upSpeed" onclick="motorCommand('upl')"></button>
  <button class="grid-item" onmousedown="motorCommand('forward');" ontouchstart="motorCommand('forward');" onmouseup="motorCommand('stop');" ontouchend="motorCommand('stop');">F</button>
  <button class="grid-item upSpeed" onclick="motorCommand('upr')"></button>
  <button class="grid-item" onmousedown="motorCommand('left');" ontouchstart="motorCommand('left');" onmouseup="motorCommand('stop');" ontouchend="motorCommand('stop');">L</button>
  <button class="grid-item stop" onclick="motorCommand('stop')">S</button>
  <button class="grid-item"onmousedown="motorCommand('right');" ontouchstart="motorCommand('right');" onmouseup="motorCommand('stop');" ontouchend="motorCommand('stop');">R</button>
  <button class="grid-item downSpeed" onclick="motorCommand('downl')"></button>
  <button class="grid-item" onmousedown="motorCommand('backward');" ontouchstart="motorCommand('backward');" onmouseup="motorCommand('stop');" ontouchend="motorCommand('stop');">B</button>
  <button class="grid-item downSpeed" onclick="motorCommand('downr')"></button>
</div>


<div id="joy1Div" style="width:200px;height:200px;margin:50px"></div>
Posizione X:<input id="joy1PosizioneX" type="text" /><br />
Posizione Y:<input id="joy1PosizioneY" type="text" /><br />
Length:<input id="joy1Length" type="text" /><br />
X :<input id="joy1X" type="text" /></br>
Y :<input id="joy1Y" type="text" />

	

<script>
//////////////////////////////////////////////////////////
// Joystick JS
///////////////////////////////////////////////////////////
let StickStatus = {
    xPosition: 0,
    yPosition: 0,
    x: 0,
    y: 0,
    length: 0
};

var JoyStick = (function(container, parameters, callback) {
    parameters = parameters || {};
    var title = (typeof parameters.title === "undefined" ? "joystick" : parameters.title),
        width = (typeof parameters.width === "undefined" ? 0 : parameters.width),
        height = (typeof parameters.height === "undefined" ? 0 : parameters.height),
        internalFillColor = (typeof parameters.internalFillColor === "undefined" ? "#00AA00" : parameters.internalFillColor),
        internalLineWidth = (typeof parameters.internalLineWidth === "undefined" ? 2 : parameters.internalLineWidth),
        internalStrokeColor = (typeof parameters.internalStrokeColor === "undefined" ? "#003300" : parameters.internalStrokeColor),
        externalLineWidth = (typeof parameters.externalLineWidth === "undefined" ? 2 : parameters.externalLineWidth),
        externalStrokeColor = (typeof parameters.externalStrokeColor ===  "undefined" ? "#008000" : parameters.externalStrokeColor),
        autoReturnToCenter = (typeof parameters.autoReturnToCenter === "undefined" ? true : parameters.autoReturnToCenter);

    callback = callback || function(StickStatus) {};

    // Create Canvas element and add it in the Container object
    var objContainer = document.getElementById(container);
    
    // Fixing Unable to preventDefault inside passive event listener due to target being treated as passive in Chrome [Thanks to https://github.com/artisticfox8 for this suggestion]
    objContainer.style.touchAction = "none";

    var canvas = document.createElement("canvas");
    canvas.id = title;
    if(width === 0) { width = objContainer.clientWidth; }
    if(height === 0) { height = objContainer.clientHeight; }
    canvas.width = width;
    canvas.height = height;
    objContainer.appendChild(canvas);
    var context=canvas.getContext("2d");

    var pressed = 0; // Bool - 1=Yes - 0=No
    var circumference = 2 * Math.PI;
    var internalRadius = (canvas.width-((canvas.width/2)+10))/2;
    var maxMoveStick = internalRadius + 5;
    var externalRadius = internalRadius + 30;
    var centerX = canvas.width / 2;
    var centerY = canvas.height / 2;
    var directionHorizontalLimitPos = canvas.width / 10;
    var directionHorizontalLimitNeg = directionHorizontalLimitPos * -1;
    var directionVerticalLimitPos = canvas.height / 10;
    var directionVerticalLimitNeg = directionVerticalLimitPos * -1;
    // Used to save current position of stick
    var movedX=centerX;
    var movedY=centerY;

    // Check if the device support the touch or not
    if("ontouchstart" in document.documentElement){
        canvas.addEventListener("touchstart", onTouchStart, false);
        document.addEventListener("touchmove", onTouchMove, false);
        document.addEventListener("touchend", onTouchEnd, false);
    } else {
        canvas.addEventListener("mousedown", onMouseDown, false);
        document.addEventListener("mousemove", onMouseMove, false);
        document.addEventListener("mouseup", onMouseUp, false);
    }
    // Draw the object
    drawExternal();
    drawInternal();

    /******************************************************
     * Private methods
     *****************************************************/

    /**
     * @desc Draw the external circle used as reference position
     */
    function drawExternal(){
        context.beginPath();
        context.arc(centerX, centerY, externalRadius, 0, circumference, false);
        context.lineWidth = externalLineWidth;
        context.strokeStyle = externalStrokeColor;
        context.stroke();
    }

    /**
     * @desc Draw the internal stick in the current position the user have moved it
     */
    function drawInternal() {
        context.beginPath();
        if(movedX<internalRadius) { movedX=maxMoveStick; }
        if((movedX+internalRadius) > canvas.width) { movedX = canvas.width-(maxMoveStick); }
        if(movedY<internalRadius) { movedY=maxMoveStick; }
        if((movedY+internalRadius) > canvas.height) { movedY = canvas.height-(maxMoveStick); }
        context.arc(movedX, movedY, internalRadius, 0, circumference, false);
        // create radial gradient
        var grd = context.createRadialGradient(centerX, centerY, 5, centerX, centerY, 200);
        // Light color
        grd.addColorStop(0, internalFillColor);
        // Dark color
        grd.addColorStop(1, internalStrokeColor);
        context.fillStyle = grd;
        context.fill();
        context.lineWidth = internalLineWidth;
        context.strokeStyle = internalStrokeColor;
        context.stroke();
    }

    function onTouchStart(event) {
        pressed = 1;
    }

    function onTouchMove(event) {
        if(pressed === 1 && event.targetTouches[0].target === canvas) {
            movedX = event.targetTouches[0].pageX;
            movedY = event.targetTouches[0].pageY;
            // Manage offset
            if(canvas.offsetParent.tagName.toUpperCase() === "BODY"){
                movedX -= canvas.offsetLeft;
                movedY -= canvas.offsetTop;
            }
            else {
                movedX -= canvas.offsetParent.offsetLeft;
                movedY -= canvas.offsetParent.offsetTop;
            }
            redrawFrame();
        }
    } 

    function getLength() {
      return Math.sqrt(Math.pow(StickStatus.x, 2) + Math.pow(StickStatus.y, 2));
    }


    function redrawFrame() {
      // Delete canvas
      context.clearRect(0, 0, canvas.width, canvas.height);
        // Redraw object
        drawExternal();
        drawInternal();

        // Set attribute of callback
        StickStatus.xPosition = movedX;
        StickStatus.yPosition = movedY;
        StickStatus.x = (100*((movedX - centerX)/maxMoveStick)).toFixed();
        StickStatus.y = ((100*((movedY - centerY)/maxMoveStick))*-1).toFixed();
        StickStatus.length = getLength();
        callback(StickStatus);
    }

    function onTouchEnd(event) {
        pressed = 0;
        // If required reset position store variable
        if(autoReturnToCenter)
        {
            movedX = centerX;
            movedY = centerY;
        }
        redrawFrame();
    }

    function onMouseDown(event) {
        pressed = 1;
    }

    /* To simplify this code there was a new experimental feature here: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/offsetX , but it present only in Mouse case not metod presents in Touch case :-( */
    function onMouseMove(event) {
        if(pressed === 1){
            movedX = event.pageX;
            movedY = event.pageY;
            // Manage offset
            if(canvas.offsetParent.tagName.toUpperCase() === "BODY")
            {
                movedX -= canvas.offsetLeft;
                movedY -= canvas.offsetTop;
            }
            else
            {
                movedX -= canvas.offsetParent.offsetLeft;
                movedY -= canvas.offsetParent.offsetTop;
            }
            redrawFrame();
        }
    }

    function onMouseUp(event) {
        pressed = 0;
        // If required reset position store variable
        if(autoReturnToCenter){
            movedX = centerX;
            movedY = centerY;
        }
        redrawFrame();
    }

    /******************************************************
     * Public methods
     *****************************************************/

    this.GetWidth = function () {
        return canvas.width;
    };

    this.GetHeight = function () {
        return canvas.height;
    };

    this.GetPosX = function (){
        return movedX;
    };

    this.GetPosY = function (){
        return movedY;
    };

    this.GetX = function (){
        return (100*((movedX - centerX)/maxMoveStick)).toFixed();
    };

    this.GetY = function (){
        return ((100*((movedY - centerY)/maxMoveStick))*-1).toFixed();
    };

});

// Create JoyStick object into the DIV 'joy1Div'

var joy1IinputPosX = document.getElementById("joy1PosizioneX");
var joy1InputPosY = document.getElementById("joy1PosizioneY");
var joy1Length = document.getElementById("joy1Length");
var joy1X = document.getElementById("joy1X");
var joy1Y = document.getElementById("joy1Y");

// Create JoyStick object into the DIV 'joy1Div'
var Joy1 = new JoyStick('joy1Div', {}, function(stickData) {
    joy1IinputPosX.value = stickData.xPosition;
    joy1InputPosY.value = stickData.yPosition;
    joy1Length.value = stickData.length;
    joy1X.value = stickData.x;
    joy1Y.value = stickData.y;
});

</script>
